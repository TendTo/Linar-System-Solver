<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linear system solver: Gaussian elimination (no pivot)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linear system solver
   </div>
   <div id="projectbrief">A linear system solver based on OpenCL aimed to take advantage of the GPU to improve the performance on large systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Gaussian elimination (no pivot) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md3"></a>
Complete explanation</h1>
<p><a href="https://en.wikipedia.org/wiki/Gaussian_elimination">Wikipedia</a></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Brief explanation</h1>
<p>Gaussian elimination (also known as Gauss-Jordan elimination or row reduction) is an algorithm in linear algebra for solving a system of linear equations. <br  />
 To perform row reduction on a matrix, a sequence of elementary row operations are used to modify the matrix until the lower left-hand corner of the matrix is filled with zeros, as much as possible. There are three types of elementary row operations:</p><ul>
<li>Swapping two rows</li>
<li>Multiplying a row by a nonzero number</li>
<li>Adding a multiple of one row to another row</li>
</ul>
<p>If the system of equation is solvable and admits only one solution vector, the matrix can be reduced to an upper triangular matrix. <br  />
 Once in this form, the system can be solved easily with some substitutions.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md6"></a>
OpenCL implementations</h1>
<p>There are 2 main parts that represent a challenge in the OpenCL implementation:</p>
<ul>
<li>each time a new pivot of index <b>i</b> has been chosen, the following <b>n - i - 1</b> reductions depend on the previous step of the algorithm.<ul>
<li>To make it clearer, let's say we have to solve a system of <b>n</b> unknowns in <b>n</b> equations. <br  />
</li>
<li>For each iteration, we choose a pivot row and column and reduce all the other rows that have not been chosen has pivots before, following the rules stated in the explanation. Once we are done, we repeat the procedure with the new values obtained in this step. <br  />
</li>
<li>To simplify even more, assume we are lucky enough to be allowed to chose these pivot rows and columns in order, from the row <b>0</b> to the row <b>n-1</b>.</li>
<li>In practice the i-th step of the algorithm needs the sub-matrix with origin (<b>i</b>, <b>i</b>) and size (<b>n - i</b> X <b>n - i + 1</b>) as input.</li>
<li>Since there is no way to force synchronization in the global memory, the only two options I see are to either launch "rows - 1" kernel plus the one to finalize the result vector or, alternatively, to store the whole matrix in local memory.</li>
</ul>
</li>
<li>calculating the result vector needs synchronization between rows, since the row of index <b>i</b> needs the result produced by the row <b>i + 1</b><ul>
<li>This is because, since the result of the algorithm is an upper triangular matrix, only the last unknown can be obtained directly, while the others depend on the previous ones.</li>
<li>On the flip-side, the action of summing all the previous solution, multiplied with the correct coefficient, can be achieved in O(log(n)) time instead of the usual O(n) by taking advantage of some parallelization.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
&lt;strong&gt;No pivot lmem&lt;/strong&gt;</h2>
<p>Simplest implementation of a Gaussian elimination where the pivots are chosen in based on the order of rows. <br  />
 The whole matrix is stored in the local memory of size (<b>n + 2</b> X <b>n + 1</b>) and all the work-items belong to the same work-group, so that they share the same local memory.</p>
<p>The parallelization only concerns the fact that the work-items go through each row in parallel, each on a specific column.</p>
<p>Finally, for each row the corresponding unknown's value is calculate, storing the temporary calculations in one row, while the <b>n</b> solutions are stored in the other.</p>
<p><object type="image/svg+xml" data="svg/GPU-no-pivot-lmem.svg" style="pointer-events: none;" width="40%">No pivot lmem</object> </p>
<p><b>Number of kernels launched: O(1)</b> <br  />
 <b>Local memory used: O(n^2)</b> <br  />
 <b>Time complexity: O(n^2)</b> <br  />
 <b>Spatial complexity: O(n^2)</b> <br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">:heavy_check_mark: Pro </th><th class="markdownTableHeadNone">:x: Cons  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The parallelization improves the time complexity </td><td class="markdownTableBodyNone">Then dimension of the matrix is limited by the amount of local memory available to the work-group  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The "no pivot" version may not be able to solve some solvable systems  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">All the work-items must belong to the same work-group  </td></tr>
</table>
<p><b>Conclusion:</b> this approach is practically useless, since the limitation of having the whole matrix stored in local memory negates the biggest benefits of using a parallel implementations, which manifest on very large sets of data.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
&lt;strong&gt;No pivot texture&lt;/strong&gt;</h2>
<p>Simplest implementation of a Gaussian elimination where the pivots are chosen in based on the order of rows. <br  />
 The whole matrix is stored in a texture. Another one with the same dimensions is created. The two textures are used alternately as input or output, a ping pong of sorts, meaning there is the need to lauch <b>n - 1</b> kernels. <br  />
 The result is that the odd reduced rows will be on one texture, while the even ones will be on the other.</p>
<p>The parallelization concerns the fact that each work-item will calculate one item of the sub-matrix. <br  />
 <em>Each frame is a different kernel</em></p>
<p><object type="image/svg+xml" data="svg/GPU-no-pivot-tex.svg" style="pointer-events: none;" width="40%">No pivot tex</object> </p>
<p>To calculate the result vector, a buffer of size 2n is allocated in the local memory. <br  />
 For each row, the corresponding unknown's value is calculate, storing the temporary calculations in the first half of the buffer, while the <b>n</b> solutions are stored in the second half.</p>
<p><object type="image/svg+xml" data="svg/GPU-solution-tex.svg" style="pointer-events: none;" width="40%">Solution tex</object> </p>
<p><b>Number of kernels launched: O(n)</b> <br  />
 <b>Local memory used: O(n)</b> <br  />
 <b>Time complexity: O(nlog(n))</b> <br  />
 <b>Spatial complexity: O(n^2)</b> <br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">:heavy_check_mark: Pro </th><th class="markdownTableHeadNone">:x: Cons  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The parallelization improves the time complexity </td><td class="markdownTableBodyNone">Needs to launch n kernels, with all the overhead this entails  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Can exploit the strong caching enjoyed by the textures </td><td class="markdownTableBodyNone">The "no pivot" version may not be able to solve some solvable systems  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The use of a texture allows only floats to be used, excluding doubles  </td></tr>
</table>
<p><b>Conclusion:</b> this approach is the fastest one for big inputs, with the limitation of being "no pivot" and working only on floats.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
&lt;strong&gt;No pivot buffer&lt;/strong&gt;</h2>
<p>Simplest implementation of a Gaussian elimination where the pivots are chosen in based on the order of rows. <br  />
 The whole matrix is stored in a buffer. Another one with the same dimensions is created. The two buffers are used alternately as input or output, a ping pong of sorts, meaning there is the need to lauch <b>n - 1</b> kernels. <br  />
 The result is that the odd reduced rows will be on one buffer, while the even ones will be on the other.</p>
<p>The parallelization concerns the fact that each work-item will calculate one item of the sub-matrix. <br  />
 <em>Each frame is a different kernel</em></p>
<p><object type="image/svg+xml" data="svg/GPU-no-pivot-buffer.svg" style="pointer-events: none;" width="40%">No pivot buffer</object> </p>
<p>To calculate the result vector, a buffer of size 2n is allocated in the local memory. <br  />
 For each row, the corresponding unknown's value is calculate, storing the temporary calculations in the first half of the buffer, while the <b>n</b> solutions are stored in the second half.</p>
<p><object type="image/svg+xml" data="svg/GPU-solution-buffer.svg" style="pointer-events: none;" width="40%">Solution buffer</object> </p>
<p><b>Number of kernels launched: O(n)</b> <br  />
 <b>Local memory used: O(n)</b> <br  />
 <b>Time complexity: O(nlog(n))</b> <br  />
 <b>Spatial complexity: O(n^2)</b> <br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">:heavy_check_mark: Pro </th><th class="markdownTableHeadNone">:x: Cons  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">The parallelization improves the time complexity </td><td class="markdownTableBodyNone">Needs to launch n kernels, with all the overhead this entails  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The "no pivot" version may not be able to solve some solvable systems  </td></tr>
</table>
<p><b>Conclusion:</b> this approach is not the fastest, but being based on a buffer leaves more room for the customization of the type of input, with the only limitation of being "no pivot".</p>
<hr  />
<p>Back to table of contents </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
